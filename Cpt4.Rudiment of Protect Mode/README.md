# Cpt4.Rudiment of Protect Mode

> 保护模式入门

## 什么是保护模式？

> CPU的发展，就是寄存器变长，运算速度变快，Intel 14nm+++++++++++++的过程

在先前的两个章节中，我们通过写MBR和Loader实现了从硬盘中读取程序代码到内存中并执行这段代码

可是细心观察的话可以发现，我们的MBR和Loader好像能直接对内存中任意地址进行操作，从显存，栈区到中断向量表。这种行为是十分危险的

加之随着计算机硬件设备的发展，我们的计算机的内存越来越大，段地址+偏移地址的寻址方式太过复杂，且20条地址线怎么都不够用。

以及最为糟糕的一点，CPU一次只能执行一个程序。

在这些种种需求和缺点的背景之下，32bit CPU和保护模式就呼之欲出了

## 实模式是什么?

> 就像中学生做小学生的题一样，可以用小学生的知识方法来做，但并不要求自己退化成小学生的知识水平。
> 如果不强调方法，甚至可以用中学知识来解小学生问题。

只是32位（以上）的CPU工作在16位（8086）工作模式下的情况，并不是说这种情况下CPU就只有16位可用

## 初见保护模式

- AX，BX，CX，DX，SI，DI，BP，SP，FLAGS，IP扩展为32位
  
  > 80286这种中间产物不在这里的讨论范畴内。
  
  命名方式为在原寄存器名前加上一个E
  
  高16位的部分只能在32位模式下使用

- 寻址方式改变
  
  **依旧使用段地址+偏移地址**，但是方式不是之前的((段寄存器<<4)+寻址寄存器)的方法
  
  新增一个数据结构——全局描述符表，储存在内存中，其大小位64字节，其中的表项称为段描述符，用于描述各个内存段内的起始地址，大小，权限等信息

  新增GDTR寄存器，指向全局描述符表

  段寄存器保存的不再是段基址，而是全局描述符表的选择子，"sector",用于索引杜全局描述符表中的段描述符
  
- 寻址寄存器不再局限于bx，dx，si，di

  几乎所有通用寄存器都可以用于寻址，就像我们今天所看到的那样


- 总结如下：

  1. 段描述符是在内存中，访问内存对 CPU 来说是比较慢的动作，效率不高。
  2. 段描述符的格式很奇怪，一个数据要分三个地方存，所以CPU要把这些七零八落的数拼合成一个完整数据也是要花时间的。

  全局描述符表将在后面的章节中讨论。

## 保护模式的指令问题

> 稍微了解过一些微软、Intel发家史的同学，都知道这两家公司最大的特点：
>
> 新产品对旧产品的兼容

在保护模式中，010代表edx寄存器

在实模式中，010代表dx寄存器

汇编编译器并不知道什么时候该生成16位指令，什么时候该生成32位指令。这个时候就得我们**手动来指定**。

```assembly
[bits 16] 告诉编译器，到下一个[bits]标签为止，下面的代码编译成16位机器码
[bits 32] 告诉编译器，到下一个[bits]标签为止，下面的代码编译成32位机器码
```

**保护模式需要手动打开**。分为三个步骤。下面这三个步骤可以不连续，也可以不顺序

1. 打开A20
2. 加载gdt
3. 将cr0的pe位置一

### 实模式下到底能不能用32位寄存器？

答案:可以。

注意下面这个表中被标黑的指令前缀 0x66。

| 指令           | 机器码           |
| -------------- | ---------------- |
| **[bits 16]**  | 伪指令，无机器码 |
| mov ax,0x1234  | B83412           |
| mov eax,0x1234 | **66**B834120000 |
| **[bits 32]**  | 伪指令，无机器码 |
| mov ax,0x1234  | **66**B83412     |
| mov eax,0x1234 | B834120000       |

- 前缀0x66 ：反转操作数大小

  在32bits模式下时，将操作数大小指定为16位（保护模式下使用实模式的指令）

  在16bits模式下时，将操作数大小指定为32位（实模式下使用保护模式的指令）

- 前缀0x67：反转寻址方式

  | 指令                    | 机器码               | 反转效果              |
  | ----------------------- | -------------------- | --------------------- |
  | **[bits 16]**           | 伪指令，无机器码     |                       |
  | mov word [bx], 0x1234   | C7073412             | 无                    |
  | mov word [eax], 0x1234  | **67**C7003412       | 在实模式使用eax寻址   |
  | mov dword [eax],0x1234  | **6667**C70034120000 | 在实模式使用eax写入dw |
  | **[bits 32]**           | 伪指令，无机器码     |                       |
  | mov dword [eax], 0x1234 | C70034120000         | 无                    |
  | mov word [eax], 0x1234  | **66**C7003412       | 操作数大小改变        |
  | mov dword [bx], 0x1234  | **67**C70734120000   | 寻址方式改变          |

### 保护模式之指令扩展

- 原先实模式下的CPU操作数仅为16位，而保护模式却到了32位。

  因此，操作数变化的指令也要跟着扩展

  例：

  ```assembly
  ;实模式指令
  add al,cl
  add ax,cx
  ;保护模式指令扩展
  add eax,ecx
  ```

- 注意，mul，div这一类多寄存器指令相比实模式有变化

  - mul指令：

    mul 指令是无符号数相乘指令，指令格式是 mul 寄存器／内存。

    其中“寄存器／内存”是乘数。 

    如果乘数是8位，则把寄存器 al 当作另一个乘数，结果便是16位，存入寄存ax。

    如果乘数是16位，则把寄存器ax当作另一个乘数，结果便是32 位，存入寄存器

    如果乘数是32位，则把寄存器eax当作另一个乘数，结果便是64位，存入edx: eax ，其中 edx 是积的高 32 位， eax是积的低 32 位。

    有符号数相乘指令 imul 也是一样，不再说明。

  - div指令

    对于无符号数除法指令div ，其格式是 div 寄存器／内存，其中的“寄存器／内存”是除法计算中的除数。 

    如果除数是8位,被除数就是 16 位，位于寄存器ax。所得的结果，商在寄存器 al ，余数在寄存器ah。

    如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx ，被除数的低 16 位则位于寄存器 ax 。所得的结果，商在寄存器ax，余数在寄存器 dx

    如果除数是 32 位，被除数就是64位，被除数的高 32 位则位于寄存器edx ，被除数的低 32 位则位于寄存器 eax，所得的结果，商在寄存器eax，余数在寄存器 edx

- push指令push的数据长度是固定长度

  - 实模式下：push 16bits数据

    如果在实模式下使用 push 0x12340000之类的指令，则像保护模式那样push进去32bits，**使用数据长度反转前缀**

  - 保护模式下：push 32bits数据

    如果在实模式下使用push 0x1234之类的指令，则像保护模式那样push进去16bits。**使用数据长度反转前缀**

  - push 段寄存器

    **长度对齐**当前模式的机器字长

  - push 通用寄存器和内存

    长度对其当前模式的机器字长

## 全局描述符表（GDT）

> 就像家庭成员需要上户口一样，在户口簿上登记过才算合法

全局描述符表（ Global Descriptor Table, GDT ）是保护模式下内存段的登记表，这是不同于实模式的显著特征之一

注意！我们只讨论x86架构下的GDT。

### 段描述符

x86架构下的描述符，长度8个字节。

为了表述方便，这里按四个字节为一个表格展示段描述符

段描述符**在内存中是连续储存的**

| 31\~24             | 23   | 22   | 21   | 20   | 19\~16             | 15   | 14\~13 | 12   | 11\~8 | 7\~0               |         |
| ------------------ | ---- | ---- | ---- | ---- | ------------------ | ---- | ------ | ---- | ----- | ------------------ | ------- |
| 段基址<br />31\~24 | G    | D/B  | L    | AVL  | 段界限<br />19\~16 | P    | DPL    | S    | TYPE  | 段基址<br />23\~16 | 高4字节 |

| 31\~16       | 15\~0       |         |
| ------------ | ----------- | ------- |
| 段基址 15\~0 | 段界限15\~0 | 低4字节 |

- **段基址**

  - **长度**：32bits

  - **功能**：描述段的基址

- **段界限** 和 **G**

  - **长度**：**20bits**  = 16 + 4(bits)

  - **单位**（粒度）：由段描述符字段 **G** 定义，仅存在两种情况
    
    - G = 1 时，单位为字节，段最大大小为$2^{20} bytes = 1MB$
  - G = 0 时，单位为4KB，段最大大小为$2^{32} bytes = 4GB$
    
  - **作用**：表示段的边界、大小、范围

  - **实际段边界值**：

    由于描述符中的**段界限是从0起**的，所以左边第1个括号中要加个1，表示 4KB 或1bytes 的实际数量。

    它与第二个括号中的段粒度大小相乘后**得到的乘积是以1为起始的段的实际大小** 由于**地址是以0为起始的**，所以公式的最后又减了1

    $(描述符中段界限 + 1) * ( 段界限的粒度大小 ) - 1$

  - 为什么**段界限被拆分为**16bits+4bits的两部分？

    你问80286去

- **TYPE**字段 和 **S**

  - **长度**：4bits（TYPE），1bit（S)

  - **作用**：TYPE 和 S 共同作用，指定本描述符的类型

    - S = 1：数据段

    - S = 0：系统段

    只有S的值确定之后，TYPE字段才有意义

  - **系统段是什么？**

    各种门，硬件系统需要的结构，而非软件使用的。比如如调用门，任务门。

    门，换言之就是个入口，通往一段程序。

    | 系统段类型           | 3    | 2    | 1    | 0    | 说明                                                         |
    | -------------------- | ---- | ---- | ---- | ---- | ------------------------------------------------------------ |
    | 未定义               | 0    | 0    | 0    | 0    | 保留                                                         |
    | 可用的80286 TSS      | 0    | 0    | 0    | 1    | 仅限80286的任务状态段                                        |
    | **LDT**              | 0    | 0    | 1    | 0    | 局部描述符表                                                 |
    | 忙碌的80286 TSS      | 0    | 0    | 1    | 1    | 仅限80286，type中的第一位称为B位，若为1，则表示当前任务忙碌，由CPU将此位置一 |
    | 80286调用门          | 0    | 1    | 0    | 0    | 仅限80286                                                    |
    | 任务门               | 0    | 1    | 0    | 1    | 现代操作系统很少用到这个                                     |
    | 80286中断门          | 0    | 1    | 1    | 0    | 仅限286                                                      |
    | 80286陷阱门          | 0    | 1    | 1    | 1    | 仅限286                                                      |
    | 未定义               | 1    | 0    | 0    | 0    | 保留                                                         |
    | **可用的80386 TSS**  | 1    | 0    | 0    | 1    | 80386以上的CPU的TSS，type第3位为1                            |
    | 未定义               | 1    | 0    | 1    | 0    | 保留                                                         |
    | **忙碌的 80386 TSS** | 1    | 0    | 1    | 1    | 80386以上的CPU的调用门，type第3位为1                         |
    | 未定义               | 1    | 1    | 0    | 1    | 保留                                                         |
    | **中断门**           | 1    | 1    | 1    | 0    | 386以上的中断门                                              |
    | **陷阱门**           | 1    | 1    | 1    | 1    | 386以上的陷阱门                                              |

  - 非系统段

    非系统段的TYPE字段分为两种，对**代码段**的描述和对**数据段**的描述
    - **代码段描述**

      | 代码段 | X    | R    | C    | A    | 说明                       |
      | ------ | ---- | ---- | ---- | ---- | -------------------------- |
      |        | 1    | 0    | 0    | *    | 只执行代码段               |
      |        | 1    | 1    | 0    | *    | 可执行、可读代码段         |
      |        | 1    | 0    | 1    | *    | 可执行、一致性代码段       |
      |        | 1    | 1    | 1    | *    | 可执行，一致性，可读代码段 |

      - **A位标识Accessed位**：这一位-由CPU设置，每当该段被CPU访问过后，CPU就将此位设置为1。A为0时，说明该段还没被CPU访问过。换言之，这个段描述符可能刚刚被创立

      - **C位标识**Conforming：一致性代码段

        一致性代码段是指如果自己是转移的目标段，并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。 

        C = 1时则表示该段是一致性代码段

        C = 0时则表示该段为非一致性代码段

    - **数据段描述**

      | 数据段 | X    | W    | E    | A    | 说明                     |
      | ------ | ---- | ---- | ---- | ---- | ------------------------ |
      |        | 0    | 0    | 0    | *    | 只读数据段               |
      |        | 0    | 1    | 0    | *    | 可读写数据段             |
      |        | 0    | 0    | 1    | *    | 只读，向下扩展的数据段   |
      |        | 0    | 1    | 1    | *    | 可读写，向下扩展的数据段 |

      - **E位标识**Extend：用来标识段的扩展方向。

        E = 0，段向上扩展

        E = 1，段向下扩展

- **DPL字段**：Descriptor Privilege Level

  - **长度**：2bits

  - **功能**：描述段的特权级别，0~3级。

    最高级为0级，最低级为3级（用户态）。通常只使用0级和3级这两层。

    有些代码得在0级下运行才能保证安全

- **P字段**:Present

  - **长度**：1bit

  - **功能**：判断段是否在内存中

    - P = 1，段在内存中
    - P = 0，段不存在于内存中

    CPU只负责检查P字段，不负责赋值。如果CPU检测到它访问了P = 0的段，则会抛出异常。

- **AVL字段**：Available

  - **长度**：4bits
  - **功能**：标志这个段是可用的。0级权限无视这个字段。用户态需要更具这个字段的值确定该段是否可用

- **L字段**

  - **长度**：1bit

  - **功能**：标志当前代码段是否为64位代码

    - L = 1：当前代码段为64bits代码

    - L = 0：当前代码段为32bits代码

    因为这本教材套路的是x86架构，所以L = 0

- **D/B字段**

  - **长度**：1bit

  - **功能**：用来指示有效地址（段内偏移地址）及操作数的大小。

    对于代码段而言，这一位是D字段

    - D = 1，指令中的有效地址和操作数是32bits
    - D = 0，指令中的有效地址和操作数是16bits

    对于栈段而言，这一位是B字段

    - B = 1，使用的是esp寄存器
    - B = 0，使用的是sp寄存器


### GDTR寄存器，与操作它的指令

GDTR寄存器的**长度为48bits**

| 47\~16          | 15\~0                 |
| --------------- | --------------------- |
| GDT内存起始地址 | GDT界限（字节为单位） |

GDTR寄存器保存了GDT的地址，和GDT表的长度信息。

通过GDTR寄存器的信息结构，我们可以推算出，GDT表的长度最大值是1MB，也就是8192个段描述符表。

不能用`mov gdtr,xxx`的方式初始化GDTR寄存器。需要用指令`lgdt`

- lgdt指令
  - **格式**：`lgdt 48bits内存数据`
  - 可在实模式和保护模式中使用
  - 需要设置GDTR寄存器后，才能进入保护模式。但是进入保护模式后，可访问的内存空间增大为4GB，需要重新安放GDT表，所以允许保护模式下使用lgdt指令

### 段寄存器与选择子（selector）

保护模式下，段寄存器储存的不再是段基址，而是GDT的选择子。

段寄存器有16bits长，和选择子长度一致。选择子并非单纯的一个数组索引，它具有一个特定的数据结构。

| 15\~3              | 2    | 1\~0 |
| ------------------ | ---- | ---- |
| 索引描述符(13bits) | TI   | RPL  |

- **RPL**

  - **长度**：2bits

  - **功能**：描述当前请求者的特权级，分为0，1，2，3共四级，同系统特权级

- **TI**：Table Indicator

  - **长度**：1bit
  - **功能**：用来指示选择子是在GDT中，还是LDT中的索引描述符
    - TI = 0：选择子在GDT中
    - TI = 1：选择子在LDT中

- **索引描述符**：

  - **长度**：13bits ，$2 ^ {13} = 8192$
  - **功能**：描述符的索引值，GDT数组索引。

### 内存分段机制在IA32下的实现

由于寄存器位数的增加，任意一个通用寄存器都可以直接访问到全部4GB的内存地址。所以段基址不再需要左右移动。

要访问的内存地址 = 段内偏移 + 段描述符中的段基址。

### GDT数组的0号位为何不使用

因为段寄存器未初始化的时候，索引值为0。这时候访问了GDT，就会出现大问题。因此GDT[0]不作为段选择子的储存使用。

## 打开A20地址线

在8086/8088cpu中，超过0xFFFFF的高位数据会被直接舍去。因此，利用这一特性搞出来的地址回绕成为了那一时代程序员的编程技巧之一。

然而80286之后，这个地址线啊，多了几条。为了保留这个技巧，Intel搞了个A20Gate

实模式下，这个A20Gate是关闭。关闭时，按早8086的地址回绕特性进行寻址

进入保护模式前，需要先打开A20Gate，解放高位地址线的开关

```assembly
in al,0x92
or al,0000_0010B
out 0x92,al
```

上述指令可以打开A20Gate

## 保护模式的开关，CR0寄存器的PE位

CRx寄存器，Control Register，用于控制CPU的运行机制，或者用于展示CPU的内部状态。

想要进入保护模式，就得将CR0的PE位设置为1

- CR0寄存器的长度：32bits

  | 31   | 30   | 29   | 28\~19 | 18   | 17   | 16   | 15\~6 | 5    | 4    | 3    | 2    | 1    | 0    |
  | ---- | ---- | ---- | ------ | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
  | PG   | CD   | NW   | 保留   | AM   | 保留 | WP   | 保留  | NE   | ET   | TS   | EM   | MP   | PE   |

  | 标志位 | 描述                             |
  | ------ | -------------------------------- |
  | PE     | Protection Enable                |
  | MP     | Monitor coProcessor/Math Present |
  | EM     | Emulation                        |
  | TS     | Task Switched                    |
  | ET     | Extention Type                   |
  | NE     | Numeric Error                    |
  | WP     | Write Protect                    |
  | AM     | Alignment Mask                   |
  | NW     | Not Writethrough                 |
  | CD     | Cache Disable                    |
  | PG     | Paging                           |

- PE = 0,表示在实模式下运行
- PE = 1,表示在保护模式下运行

```assembly
mov eax,cr0
or eax,0x00000001
mov cr0,eax
```

## 进入保护模式

看代码咯，没啥好说的了。

更新了`./include/boot.inc`和`./loader.s`

## 保护模式之内存段的保护

### 通用策略

1. 首先根据选择子的值来验证段段描述符是否越界

   其实就是GDT数组的长度检测。越界访问了自然要报错

   描述符表基址 + 选择子中的索引值*+7 <= 描述符表基址 + 描述符表界限值

   以及0号选择子不可用

2. type检查

   检查段寄存器的用途和类型是否和段类型匹配

   - 只有具备可执行属性的段（代码段）**才能加载到 cs 段寄存器**中。
   - 只具备执行属性的段（代码段）**不允许加载到除 cs 外的段寄存器**中。
   - 只有具备可写属性的段（数据段）**才能加载到 SS 栈段寄存器**中。
   - 至少具备可读属性的段**才能加载到 DS、ES 、FS、 GS 段寄存器**中。

   如果 CPU 发现有任意上述规则不符，检查就不会通过。

3. 状态检查

   检查P位以确认内存段是否存在。

   如果P = 1，则说明段存在，可以将选择子载入段寄存器。将A 置为 1 

   P值由软件检查（程序员撰写逻辑），A位由CPU自动检查

### 代码段和数据段的数据越界检查

> 实在没办法才插入一张图。
> 回头整理博客的时候会把这张图重新放进去的。github就只能sorry了

![image-20200625171352185](C:\Users\23719\AppData\Roaming\Typora\typora-user-images\image-20200625171352185.png)

如图所示。不管是数据段还是代码段，如果出现了访问上述的这种越界数据，CPU会抛出异常。

代码，数据，**应当完整的存放在段内**，不得越界。

### 栈段的保护策略

（待补充）

## 编译、虚拟硬盘读写，运行虚拟机

下面这些代码已经写成shell文件放在Cpt4文件夹里头了

```shell
cd Kernel-Learning/
cd Cpt4.Rudiment\ of\ Protect\ Mode/
nasm -o ./mbr.bin ./mbr.s
nasm -o ./loader.bin ./loader.s
cd ..
dd if=./Cpt4.Rudiment\ of\ Protect\ Mode/mbr.bin of=./bochs/bin/hd60M.img bs=512 count=1 conv=notrunc
dd if=./Cpt4.Rudiment\ of\ Protect\ Mode/loader.bin of=./bochs/bin/hd60M.img bs=512 count=4 conv=notrunc seek=2
cd ./bochs/bin
./bochs -f ./bochsrc.disk
```

## 书本勘误

160页，代码boot.inc，下面是原文代码

```assembly
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 +\
                      DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + \
                      DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
```

最后的0x00得改成0x0b，否则后边儿loader.bin运行的时候写入的字符'P'就不在显存里头了。原理请结合GDT的结构理解。

修改后的代码

```assembly
DESC_VIDEO_HIGH4 equ (0x00 << 24) + DESC_G_4K + DESC_D_32 +\
                      DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + \
                      DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b
```



# FIN

178页

