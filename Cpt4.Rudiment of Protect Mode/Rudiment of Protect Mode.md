# Cpt4.Rudiment of Protect Mode

> 保护模式入门

## 什么是保护模式？

> CPU的发展，就是寄存器变长，运算速度变快，Intel 14nm+++++++++++++的过程

在先前的两个章节中，我们通过写MBR和Loader实现了从硬盘中读取程序代码到内存中并执行这段代码

可是细心观察的话可以发现，我们的MBR和Loader好像能直接对内存中任意地址进行操作，从显存，栈区到中断向量表。这种行为是十分危险的

加之随着计算机硬件设备的发展，我们的计算机的内存越来越大，段地址+偏移地址的寻址方式太过复杂，且20条地址线怎么都不够用。

以及最为糟糕的一点，CPU一次只能执行一个程序。

在这些种种需求和缺点的背景之下，32bit CPU和保护模式就呼之欲出了

## 实模式是什么?

> 就像中学生做小学生的题一样，可以用小学生的知识方法来做，但并不要求自己退化成小学生的知识水平。
> 如果不强调方法，甚至可以用中学知识来解小学生问题。

只是32位（以上）的CPU工作在16位（8086）工作模式下的情况，并不是说这种情况下CPU就只有16位可用

## 初见保护模式

- AX，BX，CX，DX，SI，DI，BP，SP，FLAGS，IP扩展为32位
  
  > 80286这种中间产物不在这里的讨论范畴内。
  
  命名方式为在原寄存器名前加上一个E
  
  高16位的部分只能在32位模式下使用

- 寻址方式改变
  
  **依旧使用段地址+偏移地址**，但是方式不是之前的((段寄存器<<4)+寻址寄存器)的方法
  
  新增一个数据结构——全局描述符表，储存在内存中，其大小位64字节，其中的表项称为段描述符，用于描述各个内存段内的起始地址，大小，权限等信息

  新增GDTR寄存器，指向全局描述符表

  段寄存器保存的不再是段基址，而是全局描述符表的选择子，"sector",用于索引杜全局描述符表中的段描述符
  
- 寻址寄存器不再局限于bx，dx，si，di

  几乎所有通用寄存器都可以用于寻址，就像我们今天所看到的那样


- 总结如下：

  1. 段描述符是在内存中，访问内存对 CPU 来说是比较慢的动作，效率不高。
  2. 段描述符的格式很奇怪，一个数据要分三个地方存，所以CPU要把这些七零八落的数拼合成一个完整数据也是要花时间的。

  全局描述符表将在后面的章节中讨论。

## 保护模式的指令问题

> 稍微了解过一些微软、Intel发家史的同学，都知道这两家公司最大的特点：
>
> 新产品对旧产品的兼容

在保护模式中，010代表edx寄存器

在实模式中，010代表dx寄存器

汇编编译器并不知道什么时候该生成16位指令，什么时候该生成32位指令。这个时候就得我们**手动来指定**。

```assembly
[bits 16] 告诉编译器，到下一个[bits]标签为止，下面的代码编译成16位机器码
[bits 32] 告诉编译器，到下一个[bits]标签为止，下面的代码编译成32位机器码
```

**保护模式需要手动打开**。分为三个步骤。下面这三个步骤可以不连续，也可以不顺序

1. 打开A20
2. 加载gdt
3. 将cr0的pe位置一

### 实模式下到底能不能用32位寄存器？

答案:可以。

注意下面这个表中被标黑的指令前缀 0x66。

| 指令           | 机器码           |
| -------------- | ---------------- |
| **[bits 16]**  | 伪指令，无机器码 |
| mov ax,0x1234  | B83412           |
| mov eax,0x1234 | **66**B834120000 |
| **[bits 32]**  | 伪指令，无机器码 |
| mov ax,0x1234  | **66**B83412     |
| mov eax,0x1234 | B834120000       |

- 前缀0x66 ：反转操作数大小

  在32bits模式下时，将操作数大小指定为16位（保护模式下使用实模式的指令）

  在16bits模式下时，将操作数大小指定为32位（实模式下使用保护模式的指令）

- 前缀0x67：反转寻址方式

  | 指令                    | 机器码               | 反转效果              |
  | ----------------------- | -------------------- | --------------------- |
  | **[bits 16]**           | 伪指令，无机器码     |                       |
  | mov word [bx], 0x1234   | C7073412             | 无                    |
  | mov word [eax], 0x1234  | **67**C7003412       | 在实模式使用eax寻址   |
  | mov dword [eax],0x1234  | **6667**C70034120000 | 在实模式使用eax写入dw |
  | **[bits 32]**           | 伪指令，无机器码     |                       |
  | mov dword [eax], 0x1234 | C70034120000         | 无                    |
  | mov word [eax], 0x1234  | **66**C7003412       | 操作数大小改变        |
  | mov dword [bx], 0x1234  | **67**C70734120000   | 寻址方式改变          |

### 保护模式之指令扩展

- 原先实模式下的CPU操作数仅为16位，而保护模式却到了32位。

  因此，操作数变化的指令也要跟着扩展

  例：

  ```assembly
  ;实模式指令
  add al,cl
  add ax,cx
  ;保护模式指令扩展
  add eax,ecx
  ```

- 注意，mul，div这一类多寄存器指令相比实模式有变化

  - mul指令：

    mul 指令是无符号数相乘指令，指令格式是 mul 寄存器／内存。

    其中“寄存器／内存”是乘数。 

    如果乘数是8位，则把寄存器 al 当作另一个乘数，结果便是16位，存入寄存ax。

    如果乘数是16位，则把寄存器ax当作另一个乘数，结果便是32 位，存入寄存器

    如果乘数是32位，则把寄存器eax当作另一个乘数，结果便是64位，存入edx: eax ，其中 edx 是积的高 32 位， eax是积的低 32 位。

    有符号数相乘指令 imul 也是一样，不再说明。

  - div指令

    对于无符号数除法指令div ，其格式是 div 寄存器／内存，其中的“寄存器／内存”是除法计算中的除数。 

    如果除数是8位,被除数就是 16 位，位于寄存器ax。所得的结果，商在寄存器 al ，余数在寄存器ah。

    如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx ，被除数的低 16 位则位于寄存器 ax 。所得的结果，商在寄存器ax，余数在寄存器 dx

    如果除数是 32 位，被除数就是64位，被除数的高 32 位则位于寄存器edx ，被除数的低 32 位则位于寄存器 eax，所得的结果，商在寄存器eax，余数在寄存器 edx

- push指令push的数据长度是固定长度

  - 实模式下：push 16bits数据

    如果在实模式下使用 push 0x12340000之类的指令，则像保护模式那样push进去32bits，**使用数据长度反转前缀**

  - 保护模式下：push 32bits数据

    如果在实模式下使用push 0x1234之类的指令，则像保护模式那样push进去16bits。**使用数据长度反转前缀**

  - push 段寄存器

    **长度对齐**当前模式的机器字长

  - push 通用寄存器和内存

    长度对其当前模式的机器字长

## 全局描述符表（GDT）

> 就像家庭成员需要上户口一样，在户口簿上登记过才算合法

全局描述符表（ Global Descriptor Table, GDT ）是保护模式下内存段的登记表，这是不同于实模式的显著特征之一

注意！我们只讨论x86架构下的GDT。

### 段描述符

x86架构下的描述符，长度8个字节。

为了表述方便，这里按四个字节为一个表格展示段描述符

段描述符**在内存中是连续储存的**

| 31\~24             | 23   | 22   | 21   | 20   | 19\~16             | 15   | 14\~13 | 12   | 11\~8 | 7\~0               |
| ------------------ | ---- | ---- | ---- | ---- | ------------------ | ---- | ------ | ---- | ----- | ------------------ |
| 段基址<br />31\~24 | G    | D/B  | L    | AVL  | 段界限<br />19\~16 | P    | DPL    | S    | TYPE  | 段基址<br />23\~16 |

| 31\~16       | 15\~0       |
| ------------ | ----------- |
| 段基址 15\~0 | 段界限15\~0 |

- **段界限** 和 **G**

  - **长度**：**20bits**  = 16 + 4(bits)

  - **单位**（粒度）：由段描述符字段 **G** 定义，仅存在两种情况
    - G = 1 时，单位为字节，段最大大小为$2^{20} bytes = 1MB$
    - G = 0 时，单位为4KB，段最大大小为$2^{32} bytes = 4GB$

  - **作用**：表示段的边界、大小、范围

  - **实际段边界值**：

    由于描述符中的**段界限是从0起**的，所以左边第1个括号中要加个1，表示 4KB 或1bytes 的实际数量。

    它与第二个括号中的段粒度大小相乘后**得到的乘积是以1为起始的段的实际大小** 由于**地址是以0为起始的**，所以公式的最后又减了1

    $(描述符中段界限 + 1) * ( 段界限的粒度大小 ) - 1$

  - 为什么**段界限被拆分为**16bits+4bits的两部分？

    你问80286去

- **TYPE**字段

  - **长度**：4bits
  - **作用**：指定本描述符的类型

（未完待续）