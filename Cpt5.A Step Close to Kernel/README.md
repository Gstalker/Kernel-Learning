# Cpt5.A Step Close to Kernel

## 获取物理内存容量

linux系统使用`int 0x15`的三个子功能实现获取物理内存的总大小

注意:BIOS种端

- 0xE820:遍历主机上全部内存
- 0xE801:分别检测低15MB和16MB~4GB的内存，最大支持4GB
- 0x88:最多检测64MB，实际内存超过64MB也按64MB返回

### 0xE820

```assembly
;第一次调用该功能时需要设置ebx为0
mov ebx,0x00000000

;储存20字节内存段信息的缓冲区
mov ax,data
mov es,ax
mov dx,0

;固定值，向缓冲区写入的数据
mov cx,20
;固定值，校验码
mov edx,0x534d4150
;子功能号
mov eax,0x0000E820
int 0x15
```

- **功能**：遍历主机上全部内存，并返回这一块内存的相关信息

- **调用方法**：

  - 调用前输入

    **注**：若多次调用后的某一次ebx为0且cf不为1，则说明ARDS全部返回

    | 寄存器/状态位 | 参数用途                                                     |
    | ------------- | ------------------------------------------------------------ |
    | EAX           | 子功能号，0xE820                                             |
    | EBX           | ARDS后续值：内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的 ARDS 结构，所以要记录下一个待返回的内存 ARDS ，在下一次中断调用时通过 此值告诉 BIOS 该返回哪个 ARDS ，这就是后续值的作用．第一次调用时一定要置为 0，EBX 具体值我们不用关注，字取决于具体 BIOS 的实现．每次中断返回后， BIOS 会更新此值 |
    | ES:DI         | ARDS缓冲区，BIOS将获取到的内存信息写入此寄存器指向的内存，每次都已ARDS格式返回 |
    | ECX           | ARDS结构的字节大小：用来指示BIOS写入的字节数。调用者和BIOS都同时支持的大小是20字节，将来也许会扩展这个参数<br />换言之，调用前将它设置为20就对了 |
    | EDX           | 固定为签名标记0x534d4150 ，此十六进制数是字符串SMAP的ASCII码，BIOS 将调用者正在请求的内存信息写入 ES: DI 寄存器所指向的ARDS缓冲区后，再用此签名校验其中的信息<br />换言之，调用中断前将其设置为0x534d4150即可 |

  - 调用后输出

    | 寄存器/状态位 | 参数用途                                                     |
    | ------------- | ------------------------------------------------------------ |
    | CF位          | CF =0表示调用未出错， CF = 1表示调用出错                     |
    | EAX           | 字符串SMAP的ASCII码0x534d4150                                |
    | ES:DI         | ARDS 缓冲区地址，同输入值是一样的，返回时此结构中己经被 BIOS 填充了内存信息 |
    | ECX           | 同调用前                                                     |
    | EBX           | 见调用前                                                     |

    

- **返回信息**（ARDS格式）：

  每次调用这个功能，顺序遍历一块内存，并返回这块内存的信息。信息共5个字段20字节

  | 字节偏移量 | 属性名称     | 描述                           |
  | ---------- | ------------ | ------------------------------ |
  | 0          | BaseAddrLow  | 基址的低32位                   |
  | 4          | BaseAddrHigh | 基址的高32位                   |
  | 8          | LengthLow    | 内存长度的低32位，以字节为单位 |
  | 12         | LengthHigh   | 内存长度的高32位，以字节为单位 |
  | 16         | Type         | 本段内存的类型                 |

  其中，Type字段有三种类型

  | Type值 | 名称                 | 描述                                                         |
  | ------ | -------------------- | ------------------------------------------------------------ |
  | 1      | AddressRangeMemory   | 这段内存可以被操作系统使用                                   |
  | 2      | AddressRangeReserved | 内存使用中或者被系统保留，操作系统不可以使用这一块内存       |
  | 其它   | 未定义               | 未定义，以后可能用到，目前保留。但是需要操作系统一样将其视为AddressRangeReserved |

### 0xE801

- **功能**：分别检测低15MB和16MB~4GB的内存，最大支持4GB

  两组检测分别储存在两组寄存器中

  这个子程序是为了支持ISA服务而定义的。关于ISA服务导致的内存空洞，在后面的章节中有提到。

- **调用方法**：

  ```assembly
  mov ax,0xE801
  int 0x15
  ```

  返回数据如下表

  | 寄存器/状态位 | 用途        | 说明                                                         |
  | ------------- | ----------- | ------------------------------------------------------------ |
  | CF            | Carry Flag  | CF =0表示调用未出错， CF = 1表示调用出错                     |
  | AX            | Extended1   | 以1KB 为单位，只显示 15MB 以下的内存容量，故最大值为0x3c00，即 AX 表示的最大内存为 0x3c00\*1024= 15MB |
  | BX            | Extended2   | 以64KB为单位，内存空间16MB\~4GB中连续的单位数量，即内存大小为 BX\*64\*1024 字节 |
  | CX            | Configured1 | 同AX                                                         |
  | DX            | Configured2 | 同BX                                                         |

### 0x88

- **功能**：最多检测64MB，实际内存超过64MB也按64MB返回

- **调用方式**：

  ```assembly
  mov ax,0x8800
  int 0x15
  ```

  返回数据如下表:

  | 寄存器/状态位 | 参数用途                                                     |
  | ------------- | ------------------------------------------------------------ |
  | CF            | CF =0表示调用未出错， CF = 1表示调用出错                     |
  | AX            | 以1KB 为单位，内存空间1MB以上连续的单位数量，不包括低端1MB内存，故内存大小位AX\*1024字节 + 1MB |

## 内存空洞

修改bochsrc.disk内的megs词条

使用int 15的0xE801获取内存信息的时候，会出现一些有趣的事情

| megs词条 | AX     | BX   | 检测到的内存大小           |
| -------- | ------ | ---- | -------------------------- |
| 14MB     | 0x3400 | 0    | AX\*1024+BX\*64\*1024=13MB |
| 15MB     | 0x3800 | 0    | AX\*1024+BX\*64\*1024=14MB |
| 16MB     | 0x3c00 | 0    | AX\*1024+BX\*64\*1024=15MB |
| 17MB     | 0x3c00 | 0x10 | AX\*1024+BX\*64\*1024=16MB |
| 18MB     | 0x3c00 | 0x20 | AX\*1024+BX\*64\*1024=17MB |

嗯？为什么检测到的内存大小始终比我们在megs词条里头写的分配给bochs的内存要小1MB？

### 历史遗留问题：ISA设备

80286时期，有些ISA设备要用15MB~16MB的这段内存空间作为缓冲，也就是内存中有1MB作为缓冲区使用了

嗯，还是为了向下兼容。之后386的时代，这块内存就像个黑洞一样被保留下来了，成为了一个Memory hole。

有一些BIOS中可以设定开启或关闭ISA设备兼容。选项为：

`memory hole at address 15m~16m`

## 内存分页与虚拟内存

> 为什么每个程序都能把代码放在0x401000这个位置？
>
> 逆向工程逆用户程序逆的多了，就会想着进系统看看里头是些什么

### 内存为什么要分页

老生常谈的问题。引入部分就不再记录在笔记中。

### 分段机制和分页机制的关系

内存分段机制是IA32架构刻在DNA里头的东西，想寻址，就必须先经过分段访问内存。

所以，分页机制是建立在内存分段机制之上的。

**在CPU没有打开分页机制的情况下**，是按默认的分段方式进行内存寻址的，段基址和段内偏移地址经过段部件处理后所输出的线性地址，CPU就认为是物理地址

**如果打开了分页机制**，段部件输出的线性地址就不再等同于物理地址了，我们称之为虚拟地址。**虚拟地址只是逻辑上的地址，不能等同于物理地址**。CPU必须拿到物理地址才能进行物理内存寻址，**虚拟地址对应的物理地址需要在页表中查找**，这项查找工作是由**页部件自动完成**的。

要搞清楚页部件的工作原理，需要用清楚下面两个点

1. 分页机制的原理
2. 页表的结构

### 从进程的角度：分段与分页

> 有过一些逆向工程或者PWN功底的同学都知道，一个二进制程序，其代码、数据被统一的储存在硬盘中。但是加载到内存中时，这些数据、代码又被分成不同的部分加载进了不同的内存段中。

对于一个正在运行的程序而言，其所有数据都在**属于他自己的虚拟内存空间中**，这些数据和代码通过分段机制分成了若干不同的内存段。对于这个进程而言，想要访问这些代码（数据），只需要使用线性地址即可。

但是，前面提到过，虚拟地址不能直接用于寻址。

这个进程的**各个段被分成了若干大小相同的内存页**，**分散的储存**在内存的不同位置。

CPU拿到虚拟内存的线性地址后，**通过查询页表**，获取将要访问的内存页在物理内存中的实际位置。

**总结**：计算机系统没有什么问题是不能多加一个中间层解决的。

## 一级页表

页表本身是一个映射表。高位用于指示其对应的物理内存的实际地址，低位用于指示该物理页的大小

页表项结构：

| 31\~12                                 | 11\~0      |
| -------------------------------------- | ---------- |
| 内存页的物理地址（$2^{20}$=1048576个） | 内存块信息 |

### 有关分页机制的两个注意点

- 打开分页机制前，需要将页表的物理地址加载到控制寄存器cr3中，这是启动分页机制的先决条件之一。

- 在利用分页机制将虚拟地址转化成物理地址的这一过程中，所有的计算都是在物理地址模式下进行的。要不就产生递归了

### 一级页表地址转换原理

1. 一个页表项对应一个页，用线性地址的高20位*4作为页表数组的索引获取内存页的物理地址
2. 内存页的物理地址 + 线性地址的低20位 = 需要访问的物理地址
3. 该算法通过CPU的页部件自动计算，无需操作系统担心。

## 二级页表

### 为什么需要二级页表

- 一级页表最多容纳1048576个表项，每个表项是4字节。如果表全满，则页表需要占用4MB大小
  现在别以为4MB没多大，要知道，我们给虚拟机配置的内存也就32MB
- 一级页表必须在操作系统启动的时候就建立好。因为操作系统要占用4GB虚拟地址的1GB空间，用户进程要占用3GB空间。
- 每个进程都有自己的页表，进程一多，光是页表占用的空间就很大很大了。

因此，我们需要动态的创建页表项。并且要做到每个进程都有自己的页表

###  二级页表的结构：

二级map映射

- **页目录表**：

  **数量**：1024个

  **大小**：4kb（刚好一个内存页大小）

  **内容**：1024个页表的物理地址

  | 31\~12                 | 11\~9 | 8    | 7     | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
  | ---------------------- | ----- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 页表物理页地址31\~12位 | AVL   | G    | **O** | D    | A    | PCD  | PWT  | US   | RW   | P    |

- **页表**

  **数量**：1个

  **大小**：4kb

  **内容**：1024个表项--实际的物理地址

  | 31\~12             | 11\~9 | 8    | 7       | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
  | ------------------ | ----- | ---- | ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 物理页地址31\~12位 | AVL   | G    | **PAT** | D    | A    | PCD  | PWT  | US   | RW   | P    |

- 各个位的含义：

  - **P**：Present ,存在位，若为1说明该页存在于物理内存中，为0说明不再物理内存中。操作系统的页式虚存管理概念是通过P位和相应的pagefault来实现的
  - **RW**： Read/write，若为1表示可读可写，若为0表示可读不可写
  - **US**：User/Supervisor,普通用户/超级用户位。若为1时，表示处于User级，特权0,1,2,3级都可以访问该页面。若为0时，Tier 3不允许访问该物理页。
  - **PWT**：Page-level Write-Through,意为页级通写位，也称页级写透位。若为1表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，”通写“高速缓存的一种工作方式，本位用来简介决定是否用此方式改善该页的访问效率。我们设置它为0
  - **PCD**：Page-level Cache Disable,意为页级高速缓存禁止位，若为1表示该页启用高速缓存，0表示禁止讲该页缓存。我们设置它为0
  - **A**：Accessed，若为1，说明CPU访问过这个页。由操作系统置0，用于统计访问次数，以做到外存交换。
  - **D**：Dirty ，意为脏页位。当CPU对一个页面执行写操作时，就会设置对应表项为1.此项仅对页表想有效，并且不会修该页目录项中的D位。
  - **PAT**：Page Attribute Table ,意为页属性位表，能够在页面一级的粒度上设置内存属性，比较复杂，这里我们设置为0
  - **G**：Global，意为全局位。由于内存地址转换颇费周折，先得拆分虚拟地址，又要查页目录，又要查页表，所以为了提高获取物理地址的速度，将虚拟地址与物理地址的转换结果储存在TLB中。TLB用来缓存转换结果的高速缓存。
  - **AVL**，Available,表示可用。CPU不理会这个位，软件/操作系统可用这个位。

### 二级页表的寻址方式

- 线性地址的结构

  | 31\~22                                | 21\~12             | 11\~0  |
  | ------------------------------------- | ------------------ | ------ |
  | 作为页目录表数组的索引$2^{10}$ = 1024 | 作为页表数组的索引 | offset |

1. 高10位\*4作为页目录表的索引，找到页表的物理地址
2. 中间10位*4作为页表的索引，找到物理页的物理地址
3. 物理页地址 +　offset =  需要访问的物理地址，直接送上总线

## 启动分页机制需要做的事情

1. 准备好页目录表和页表
2. 将页表地址写入cr3
3. 寄存器cr0的PG位置为1

### 将页目录表地址写入cr3

cr3的结构：

| 31\~12           | 11\~5 | 4    | 3    | 2    | 1    | 0    |
| ---------------- | ----- | ---- | ---- | ---- | ---- | ---- |
| 页目录表物理地址 |       | PCD  | PWT  |      |      |      |

我们只需要把上表中写出来的东西放进去就好。PCD,PWT置0

```assembly
mov eax,cr3
...
mov cr3,eax
```

### 将cr0的PG位置0

```assembly
mov eax,cr0
or eax,0x80000000
mov cr0,eax
```

## 规划页表：操作系统与用户进程的关系

操作系统必须共享给所有用户进程。但是用户能用哪些功能，由操作系统决定，不是用户想用什么就用什么。

如何规划：操作系统属于用户进程的虚拟地址空间。

我们决定这样来做：

| 3~4GB | 操作系统空间 |
| ----- | ------------ |
| 0~3GB | 用户进程空间 |

我们的操作系统内核比较简单，所以占用内存量少，最终大小在70kb左右。我们选择把操作系统加载在0\~0xfffff这个区间的物理内存内，然后把这块物理内存映射到虚拟内存的高位地址。

