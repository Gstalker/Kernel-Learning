# Cpt5.A Step Close to Kernel

## 获取物理内存容量

linux系统使用`int 0x15`的三个子功能实现获取物理内存的总大小

注意:BIOS种端

- 0xE820:遍历主机上全部内存
- 0xE801:分别检测低15MB和16MB~4GB的内存，最大支持4GB
- 0x88:最多检测64MB，实际内存超过64MB也按64MB返回

### 0xE820

```assembly
;第一次调用该功能时需要设置ebx为0
mov ebx,0x00000000

;储存20字节内存段信息的缓冲区
mov ax,data
mov es,ax
mov dx,0

;固定值，向缓冲区写入的数据
mov cx,20
;固定值，校验码
mov edx,0x534d4150
;子功能号
mov eax,0x0000E820
int 0x15
```

- **功能**：遍历主机上全部内存，并返回这一块内存的相关信息

- **调用方法**：

  - 调用前输入

    **注**：若多次调用后的某一次ebx为0且cf不为1，则说明ARDS全部返回

    | 寄存器/状态位 | 参数用途                                                     |
    | ------------- | ------------------------------------------------------------ |
    | EAX           | 子功能号，0xE820                                             |
    | EBX           | ARDS后续值：内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的 ARDS 结构，所以要记录下一个待返回的内存 ARDS ，在下一次中断调用时通过 此值告诉 BIOS 该返回哪个 ARDS ，这就是后续值的作用．第一次调用时一定要置为 0，EBX 具体值我们不用关注，字取决于具体 BIOS 的实现．每次中断返回后， BIOS 会更新此值 |
    | ES:DI         | ARDS缓冲区，BIOS将获取到的内存信息写入此寄存器指向的内存，每次都已ARDS格式返回 |
    | ECX           | ARDS结构的字节大小：用来指示BIOS写入的字节数。调用者和BIOS都同时支持的大小是20字节，将来也许会扩展这个参数<br />换言之，调用前将它设置为20就对了 |
    | EDX           | 固定为签名标记0x534d4150 ，此十六进制数是字符串SMAP的ASCII码，BIOS 将调用者正在请求的内存信息写入 ES: DI 寄存器所指向的ARDS缓冲区后，再用此签名校验其中的信息<br />换言之，调用中断前将其设置为0x534d4150即可 |

  - 调用后输出

    | 寄存器/状态位 | 参数用途                                                     |
    | ------------- | ------------------------------------------------------------ |
    | CF位          | CF =0表示调用未出错， CF = 1表示调用出错                     |
    | EAX           | 字符串SMAP的ASCII码0x534d4150                                |
    | ES:DI         | ARDS 缓冲区地址，同输入值是一样的，返回时此结构中己经被 BIOS 填充了内存信息 |
    | ECX           | 同调用前                                                     |
    | EBX           | 见调用前                                                     |

    

- **返回信息**（ARDS格式）：

  每次调用这个功能，顺序遍历一块内存，并返回这块内存的信息。信息共5个字段20字节

  | 字节偏移量 | 属性名称     | 描述                           |
  | ---------- | ------------ | ------------------------------ |
  | 0          | BaseAddrLow  | 基址的低32位                   |
  | 4          | BaseAddrHigh | 基址的高32位                   |
  | 8          | LengthLow    | 内存长度的低32位，以字节为单位 |
  | 12         | LengthHigh   | 内存长度的高32位，以字节为单位 |
  | 16         | Type         | 本段内存的类型                 |

  其中，Type字段有三种类型

  | Type值 | 名称                 | 描述                                                         |
  | ------ | -------------------- | ------------------------------------------------------------ |
  | 1      | AddressRangeMemory   | 这段内存可以被操作系统使用                                   |
  | 2      | AddressRangeReserved | 内存使用中或者被系统保留，操作系统不可以使用这一块内存       |
  | 其它   | 未定义               | 未定义，以后可能用到，目前保留。但是需要操作系统一样将其视为AddressRangeReserved |

### 0xE801

- **功能**：分别检测低15MB和16MB~4GB的内存，最大支持4GB

  两组检测分别储存在两组寄存器中

  这个子程序是为了支持ISA服务而定义的。关于ISA服务导致的内存空洞，在后面的章节中有提到。

- **调用方法**：

  ```assembly
  mov ax,0xE801
  int 0x15
  ```

  返回数据如下表

  | 寄存器/状态位 | 用途        | 说明                                                         |
  | ------------- | ----------- | ------------------------------------------------------------ |
  | CF            | Carry Flag  | CF =0表示调用未出错， CF = 1表示调用出错                     |
  | AX            | Extended1   | 以1KB 为单位，只显示 15MB 以下的内存容量，故最大值为0x3c00，即 AX 表示的最大内存为 0x3c00\*1024= 15MB |
  | BX            | Extended2   | 以64KB为单位，内存空间16MB\~4GB中连续的单位数量，即内存大小为 BX\*64\*1024 字节 |
  | CX            | Configured1 | 同AX                                                         |
  | DX            | Configured2 | 同BX                                                         |

### 0x88

- **功能**：最多检测64MB，实际内存超过64MB也按64MB返回

- **调用方式**：

  ```assembly
  mov ax,0x8800
  int 0x15
  ```

  返回数据如下表:

  | 寄存器/状态位 | 参数用途                                                     |
  | ------------- | ------------------------------------------------------------ |
  | CF            | CF =0表示调用未出错， CF = 1表示调用出错                     |
  | AX            | 以1KB 为单位，内存空间1MB以上连续的单位数量，不包括低端1MB内存，故内存大小位AX\*1024字节 + 1MB |

## 内存空洞

修改bochsrc.disk内的megs词条

使用int 15的0xE801获取内存信息的时候，会出现一些有趣的事情

| megs词条 | AX     | BX   | 检测到的内存大小           |
| -------- | ------ | ---- | -------------------------- |
| 14MB     | 0x3400 | 0    | AX\*1024+BX\*64\*1024=13MB |
| 15MB     | 0x3800 | 0    | AX\*1024+BX\*64\*1024=14MB |
| 16MB     | 0x3c00 | 0    | AX\*1024+BX\*64\*1024=15MB |
| 17MB     | 0x3c00 | 0x10 | AX\*1024+BX\*64\*1024=16MB |
| 18MB     | 0x3c00 | 0x20 | AX\*1024+BX\*64\*1024=17MB |

嗯？为什么检测到的内存大小始终比我们在megs词条里头写的分配给bochs的内存要小1MB？

### 历史遗留问题：ISA设备

80286时期，有些ISA设备要用15MB~16MB的这段内存空间作为缓冲，也就是内存中有1MB作为缓冲区使用了

嗯，还是为了向下兼容。之后386的时代，这块内存就像个黑洞一样被保留下来了，成为了一个Memory hole。

有一些BIOS中可以设定开启或关闭ISA设备兼容。选项为：

`memory hole at address 15m~16m`

## 内存分页与虚拟内存

> 为什么每个程序都能把代码放在0x401000这个位置？
>
> 逆向工程逆用户程序逆的多了，就会想着进系统看看里头是些什么

### 内存为什么要分页

老生常谈的问题。引入部分就不再记录在笔记中。

### 分段机制和分页机制的关系

内存分段机制是IA32架构刻在DNA里头的东西，想寻址，就必须先经过分段访问内存。

所以，分页机制是建立在内存分段机制之上的。

**在CPU没有打开分页机制的情况下**，是按默认的分段方式进行内存寻址的，段基址和段内偏移地址经过段部件处理后所输出的线性地址，CPU就认为是物理地址

**如果打开了分页机制**，段部件输出的线性地址就不再等同于物理地址了，我们称之为虚拟地址。**虚拟地址只是逻辑上的地址，不能等同于物理地址**。CPU必须拿到物理地址才能进行物理内存寻址，**虚拟地址对应的物理地址需要在页表中查找**，这项查找工作是由**页部件自动完成**的。

要搞清楚页部件的工作原理，需要用清楚下面两个点

1. 分页机制的原理
2. 页表的结构

### 从进程的角度：分段与分页

> 有过一些逆向工程或者PWN功底的同学都知道，一个二进制程序，其代码、数据被统一的储存在硬盘中。但是加载到内存中时，这些数据、代码又被分成不同的部分加载进了不同的内存段中。

对于一个正在运行的程序而言，其所有数据都在**属于他自己的虚拟内存空间中**，这些数据和代码通过分段机制分成了若干不同的内存段。对于这个进程而言，想要访问这些代码（数据），只需要使用线性地址即可。

但是，前面提到过，虚拟地址不能直接用于寻址。

这个进程的**各个段被分成了若干大小相同的内存页**，**分散的储存**在内存的不同位置。

CPU拿到虚拟内存的线性地址后，**通过查询页表**，获取将要访问的内存页在物理内存中的实际位置。

**总结**：计算机系统没有什么问题是不能多加一个中间层解决的。

## 一级页表

(未完待续)